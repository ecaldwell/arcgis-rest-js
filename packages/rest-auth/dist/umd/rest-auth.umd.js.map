{"version":3,"file":"rest-auth.umd.js","sources":["../../src/fetchToken.ts","../../src/generateToken.ts","../../src/UserSession.ts","../../src/ApplicationSession.ts"],"sourcesContent":["import { request, IParams } from \"@esri/rest-request\";\n\nexport type GrantTypes =\n  | \"authorization_code\"\n  | \"refresh_token\"\n  | \"client_credentials\"\n  | \"exchange_refresh_token\";\n\nexport interface IFetchTokenParams extends IParams {\n  client_id: string;\n  client_secret?: string;\n  grant_type: GrantTypes;\n  redirect_uri?: string;\n  refresh_token?: string;\n  code?: string;\n}\n\ninterface IFetchTokenRawResponse {\n  access_token: string;\n  expires_in: number;\n  username: string;\n  refresh_token?: string;\n}\n\nexport interface IFetchTokenResponse {\n  token: string;\n  expires: Date;\n  username: string;\n  refreshToken?: string;\n}\n\nexport function fetchToken(\n  url: string,\n  params: IFetchTokenParams\n): Promise<IFetchTokenResponse> {\n  return request(url, params).then((response: IFetchTokenRawResponse) => {\n    const r: IFetchTokenResponse = {\n      token: response.access_token,\n      username: response.username,\n      expires: new Date(\n        Date.now() + (response.expires_in * 60 * 1000 - 60 * 1000)\n      )\n    };\n    if (response.refresh_token) {\n      r.refreshToken = response.refresh_token;\n    }\n\n    return r;\n  });\n}\n","import { request, IParams } from \"@esri/rest-request\";\n\nexport interface IGenerateTokenParams extends IParams {\n  username?: string;\n  password?: string;\n  expiration?: number;\n  token?: string;\n  serverUrl?: string;\n}\n\nexport interface IGenerateTokenResponse {\n  token: string;\n  expires: number;\n  ssl: boolean;\n}\n\nexport function generateToken(\n  url: string,\n  params: IGenerateTokenParams\n): Promise<IGenerateTokenResponse> {\n  /* istanbul ignore else */\n  if (\n    typeof window !== \"undefined\" &&\n    window.location &&\n    window.location.host\n  ) {\n    params.referer = window.location.host;\n  } else {\n    params.referer = \"@esri.rest-auth\";\n  }\n\n  return request(url, params);\n}\n","import * as http from \"http\";\nimport {\n  request,\n  ArcGISAuthError,\n  ArcGISRequestError,\n  IAuthenticationManager\n} from \"@esri/rest-request\";\nimport { generateToken } from \"./generateToken\";\nimport { fetchToken, IFetchTokenResponse } from \"./fetchToken\";\n\n/**\n * Internal utility for resolving a Promise from outside its constructor.\n *\n * See: http://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/\n */\ninterface IDeferred<T> {\n  promise: Promise<T>;\n  resolve: (v: T) => void;\n  reject: (v: any) => void;\n}\n\nfunction defer<T>(): IDeferred<T> {\n  const deferred: any = {\n    promise: null,\n    resolve: null,\n    reject: null\n  };\n\n  deferred.promise = new Promise((resolve, reject) => {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n\n  return deferred as IDeferred<T>;\n}\n\n/**\n * Options for static OAuth 2.0 helper methods on `UserSession`.\n */\nexport interface IOauth2Options {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId: string;\n\n  /**\n   * A valid URL to redirect to after a user authorizes your application. Can be set on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  redirectUri: string;\n\n  /**\n   * Determines wether to open the authorization window in a new tab/window or in the current window.\n   *\n   * @browserOnly\n   */\n  popup?: boolean;\n\n  /**\n   * The ArcGIS Online or ArcGIS Enterprise portal you want to use for authentication. Defaults to `https://www.arcgis.com/sharing/rest` for the ArcGIS Online portal.\n   */\n  portal?: string;\n\n  /** Default duration you would to obtain tokens for in minutes. Defaults to 20160 minutes (two weeks). */\n  duration?: number;\n}\n\n/**\n * Options for the `UserSession` constructor.\n */\nexport interface IUserSessionOptions {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId?: string;\n\n  /**\n   * A valid URL to redirect to after a user authorizes your application. Can be set on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  redirectUri?: string;\n\n  /**\n   * OAuth 2.0 refresh token from a previous user session.\n   */\n  refreshToken?: string;\n\n  /**\n   * Expiration date of the `refreshToken`\n   */\n  refreshTokenExpires?: Date;\n\n  /**\n   * The authenticated users username. Guaranteed to be unique across ArcGIS Online or your instance of ArcGIS Enterprise.\n   */\n  username?: string;\n\n  /**\n   * Password for this user. Used in CLI apps where users cannot do OAuth 2.0.\n   */\n  password?: string;\n\n  /**\n   * OAuth 2.0 access token from a previous user session.\n   */\n  token?: string;\n\n  /**\n   * Expiration date for the `token`\n   */\n  tokenExpires?: Date;\n\n  /**\n   * The ArcGIS Online or ArcGIS Enterprise portal you want to use for authentication. Defaults to `https://www.arcgis.com/sharing/rest` for the ArcGIS Online portal.\n   */\n  portal?: string;\n\n  /**\n   * Duration of requested tokens in minutes. Used when requesting tokens with `username` and `password` for when validating the identities of unknown servers. Defaults to 2 weeks.\n   */\n  tokenDuration?: number;\n\n  /**\n   * Original duration of the refresh token from a previous user session.\n   */\n  refreshTokenDuration?: number;\n}\n\n/**\n * Used to manage the authentication of ArcGIS Online and ArcGIs Enterprise users\n * in [`request`](/api/rest-request/request/). This class also includes several\n * helper methods for authenticating users with OAuth 2.0 in both browser and\n * server applications.\n */\nexport class UserSession implements IAuthenticationManager {\n  /**\n   * Client ID being used for authentication if provided in the `constructor`.\n   */\n  readonly clientId: string;\n\n  /**\n   * The currently authenticated user if provided in the `constructor`.\n   */\n  readonly username: string;\n\n  /**\n   * The currently authenticated user's password if provided in the `constructor`.\n   */\n  readonly password: string;\n\n  /**\n   * The current portal the user is authenticated with.\n   */\n  readonly portal: string;\n\n  /**\n   * Determines how long new tokens requested are valid.\n   */\n  readonly tokenDuration: number;\n\n  /**\n   * A valid redirect URI for this application if provided in the `constructor`.\n   */\n  readonly redirectUri: string;\n\n  /**\n   * Duration of new OAuth 2.0 refresh token validity.\n   */\n  readonly refreshTokenDuration: number;\n\n  private _token: string;\n  private _tokenExpires: Date;\n  private _refreshToken: string;\n  private _refreshTokenExpires: Date;\n\n  /**\n   * Internal list of trusted 3rd party servers (federated servers) that have\n   *  been validated with `generateToken`.\n   */\n  private trustedServers: {\n    [key: string]: {\n      token: string;\n      expires: Date;\n    };\n  };\n\n  /**\n   * The current ArcGIS Online or ArcGIS Enterprise `token`.\n   */\n  get token() {\n    return this._token;\n  }\n\n  /**\n   * The expiration time of the current `token`.\n   */\n  get tokenExpires() {\n    return this._tokenExpires;\n  }\n\n  /**\n   * The current token to ArcGIS Online or ArcGIS Enterprise.\n   */\n  get refreshToken() {\n    return this._refreshToken;\n  }\n\n  /**\n   * The expiration time of the current `refreshToken`.\n   */\n  get refreshTokenExpires() {\n    return this._refreshTokenExpires;\n  }\n\n  constructor(options: IUserSessionOptions) {\n    this.clientId = options.clientId;\n    this._refreshToken = options.refreshToken;\n    this._refreshTokenExpires = options.refreshTokenExpires;\n    this.username = options.username;\n    this.password = options.password;\n    this._token = options.token;\n    this._tokenExpires = options.tokenExpires;\n    this.portal = options.portal || \"https://www.arcgis.com/sharing/rest\";\n    this.tokenDuration = options.tokenDuration || 20160;\n    this.redirectUri = options.redirectUri;\n    this.refreshTokenDuration = options.refreshTokenDuration || 20160;\n    this.trustedServers = {};\n  }\n\n  /**\n   * Begins a new browser-based OAuth 2.0 sign in. If `options.popup` is true the\n   * authentication window will open in a new tab/window otherwise the user will\n   * be redirected to the authorization page in their current tab.\n   *\n   * @browserOnly\n   */\n  static beginOAuth2(\n    options: IOauth2Options,\n    /* istanbul ignore next */ win: any = window\n  ) {\n    const { portal, clientId, duration, redirectUri, popup }: IOauth2Options = {\n      ...{\n        portal: \"https://arcgis.com/sharing/rest\",\n        duration: 20160,\n        popup: true\n      },\n      ...options\n    };\n\n    const url = `${portal}/oauth2/authorize?client_id=${clientId}&response_type=token&expiration=${duration}&redirect_uri=${encodeURIComponent(\n      redirectUri\n    )}`;\n\n    if (!popup) {\n      win.location.href = url;\n      return;\n    }\n\n    const session = defer<UserSession>();\n\n    win[`__ESRI_REST_AUTH_HANDLER_${clientId}`] = function(\n      error: any,\n      oauthInfo: IFetchTokenResponse\n    ) {\n      if (error) {\n        session.reject(error);\n        return;\n      }\n\n      session.resolve(\n        new UserSession({\n          clientId,\n          portal,\n          token: oauthInfo.token,\n          tokenExpires: oauthInfo.expires,\n          username: oauthInfo.username\n        })\n      );\n    };\n\n    win.open(\n      url,\n      \"oauth-window\",\n      \"height=400,width=600,menubar=no,location=yes,resizable=yes,scrollbars=yes,status=yes\"\n    );\n\n    return session.promise;\n  }\n\n  /**\n   * Completes a browser-based OAuth 2.0 sign if `options.popup` is true the user\n   * will be returned to the previous window. Otherwise a new `UserSession`\n   * will be returned.\n   *\n   * @browserOnly\n   */\n  static completeOAuth2(\n    options: IOauth2Options,\n    /* istanbul ignore next*/ win: any = window\n  ) {\n    const { portal, clientId, duration, redirectUri }: IOauth2Options = {\n      ...{ portal: \"https://arcgis.com/sharing/rest\", duration: 20160 },\n      ...options\n    };\n\n    function completeSignIn(error: any, oauthInfo: IFetchTokenResponse) {\n      if (win.opener && win.opener.parent) {\n        win.opener.parent[`__ESRI_REST_AUTH_HANDLER_${clientId}`](\n          error,\n          oauthInfo\n        );\n        win.close();\n        return;\n      }\n\n      if (win.parent) {\n        win.parent[`__ESRI_REST_AUTH_HANDLER_${clientId}`](error, oauthInfo);\n        win.close();\n        return;\n      }\n\n      if (error) {\n        throw error;\n      }\n\n      return new UserSession({\n        clientId,\n        portal,\n        token: oauthInfo.token,\n        tokenExpires: oauthInfo.expires,\n        username: oauthInfo.username\n      });\n    }\n\n    const match = win.location.href.match(\n      /access_token=(.+)&expires_in=(.+)&username=(.+)/\n    );\n\n    if (!match) {\n      const errorMatch = win.location.href.match(\n        /error=(.+)&error_description=(.+)/\n      );\n\n      const error = errorMatch[1];\n      const errorMessage = decodeURIComponent(errorMatch[2]);\n\n      return completeSignIn(new ArcGISRequestError(errorMessage, error), null);\n    }\n\n    const token = match[1];\n    const expires = new Date(\n      Date.now() + parseInt(match[2], 10) * 1000 - 60 * 1000\n    );\n    const username = match[3];\n\n    return completeSignIn(null, {\n      token,\n      expires,\n      username\n    });\n  }\n\n  /**\n   * Begins a new server-based OAuth 2.0 sign in. This will redirect the user to\n   * the ArcGIS Online or ArcGIS Enterprise authorization page.\n   *\n   * @nodeOnly\n   */\n  static authorize(options: IOauth2Options, response: http.ServerResponse) {\n    const { portal, clientId, duration, redirectUri }: IOauth2Options = {\n      ...{ portal: \"https://arcgis.com/sharing/rest\", duration: 20160 },\n      ...options\n    };\n\n    response.writeHead(301, {\n      Location: `${portal}/oauth2/authorize?client_id=${clientId}&duration=${duration}&response_type=code&redirect_uri=${encodeURIComponent(\n        redirectUri\n      )}`\n    });\n\n    response.end();\n  }\n\n  /**\n   * Completes the server-based OAuth 2.0 sign in process by exchanging the `authorizationCode`\n   * for a `access_token`.\n   *\n   * @nodeOnly\n   */\n  static exchangeAuthorizationCode(\n    options: IOauth2Options,\n    authorizationCode: string\n  ): Promise<UserSession> {\n    const { portal, clientId, duration, redirectUri }: IOauth2Options = {\n      ...{ portal: \"https://www.arcgis.com/sharing/rest\", duration: 20160 },\n      ...options\n    };\n\n    return fetchToken(`${portal}/oauth2/token`, {\n      grant_type: \"authorization_code\",\n      client_id: clientId,\n      redirect_uri: redirectUri,\n      code: authorizationCode\n    }).then(response => {\n      return new UserSession({\n        clientId,\n        portal,\n        redirectUri,\n        refreshToken: response.refreshToken,\n        refreshTokenDuration: duration,\n        refreshTokenExpires: new Date(Date.now() + (duration - 60) * 1000),\n        token: response.token,\n        tokenExpires: response.expires,\n        username: response.username\n      });\n    });\n  }\n\n  static deserialize(str: string) {\n    const options = JSON.parse(str);\n    return new UserSession({\n      clientId: options.clientId,\n      refreshToken: options.refreshToken,\n      refreshTokenExpires: new Date(options.refreshTokenExpires),\n      username: options.username,\n      password: options.password,\n      token: options.token,\n      tokenExpires: new Date(options.tokenExpires),\n      portal: options.portal,\n      tokenDuration: options.tokenDuration,\n      redirectUri: options.redirectUri,\n      refreshTokenDuration: options.refreshTokenDuration\n    });\n  }\n\n  /**\n   * Gets a appropriate token for the given URL. If `portal` is ArcGIS Online and\n   * the request is to an ArcGIS Online domain `token` will be used. If the request\n   * is to the current `portal` the current `token` will also be used. However if\n   * the request is to an unknown server we will validate the server with a request\n   * to our current `portal`.\n   */\n  getToken(url: string) {\n    if (\n      this.portal === \"https://www.arcgis.com/sharing/rest\" &&\n      /^https?:\\/\\/\\S+\\.arcgis\\.com.+/.test(url)\n    ) {\n      return this.getFreshToken();\n    } else if (new RegExp(this.portal).test(url)) {\n      return this.getFreshToken();\n    } else {\n      return this.getTokenForServer(url);\n    }\n  }\n\n  toJSON(): IUserSessionOptions {\n    return {\n      clientId: this.clientId,\n      refreshToken: this.refreshToken,\n      refreshTokenExpires: this.refreshTokenExpires,\n      username: this.username,\n      password: this.password,\n      token: this.token,\n      tokenExpires: this.tokenExpires,\n      portal: this.portal,\n      tokenDuration: this.tokenDuration,\n      redirectUri: this.redirectUri,\n      refreshTokenDuration: this.refreshTokenDuration\n    };\n  }\n\n  serialize() {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Manually refreshes the current `token` and `tokenExpires`.\n   */\n  refreshSession(): Promise<UserSession> {\n    if (this.username && this.password) {\n      return this.refreshWithUsernameAndPassword();\n    }\n\n    if (this.clientId && this.refreshToken) {\n      return this.refreshWithRefreshToken();\n    }\n\n    return Promise.reject(new Error(\"Unable to refresh token.\"));\n  }\n\n  /**\n   * Validates that a given URL is properly federated with our current `portal`.\n   * Attempts to use the internal `trustedServers` cache first.\n   */\n  private getTokenForServer(url: string) {\n    const [root] = url.split(\"/rest/services/\");\n    const existingToken = this.trustedServers[root];\n\n    if (existingToken && existingToken.expires.getTime() > Date.now()) {\n      return Promise.resolve(existingToken.token);\n    }\n\n    return request(`${root}/rest/info`)\n      .then((response: any) => {\n        return response.owningSystemUrl;\n      })\n      .then(owningSystemUrl => {\n        /**\n         * if this server is not owned by this portal bail out with an error\n         * since we know we wont be able to generate a token\n         */\n        if (!new RegExp(owningSystemUrl).test(this.portal)) {\n          throw new ArcGISAuthError(\n            `${url} is not federated with ${this.portal}.`,\n            \"NOT_FEDERATED\"\n          );\n        }\n        return request(`${owningSystemUrl}/sharing/rest/info`);\n      })\n      .then((response: any) => {\n        return response.authInfo.tokenServicesUrl;\n      })\n      .then((tokenServicesUrl: string) => {\n        return generateToken(tokenServicesUrl, {\n          token: this.token,\n          serverUrl: url,\n          expiration: this.tokenDuration\n        });\n      })\n      .then(response => {\n        this.trustedServers[root] = {\n          expires: new Date(response.expires),\n          token: response.token\n        };\n        return response.token;\n      });\n  }\n\n  /**\n   * Returns an unexpired token for the current `portal`.\n   */\n  private getFreshToken() {\n    if (\n      this.token &&\n      this.tokenExpires &&\n      this.tokenExpires.getTime() > Date.now()\n    ) {\n      return Promise.resolve(this.token);\n    }\n\n    return this.refreshSession().then(session => session.token);\n  }\n\n  /**\n   * Refreshes the current `token` and `tokenExpires` with `username` and\n   * `password`.\n   */\n  private refreshWithUsernameAndPassword() {\n    return generateToken(`${this.portal}/generateToken`, {\n      username: this.username,\n      password: this.password,\n      expiration: this.tokenDuration\n    }).then((response: any) => {\n      this._token = response.token;\n      this._tokenExpires = new Date(response.expires);\n      return this;\n    });\n  }\n\n  /**\n   * Refreshes the current `token` and `tokenExpires` with `refreshToken`.\n   */\n  private refreshWithRefreshToken() {\n    if (\n      this.refreshToken &&\n      this.refreshTokenExpires &&\n      this.refreshTokenExpires.getTime() < Date.now()\n    ) {\n      return this.refreshRefreshToken();\n    }\n\n    return fetchToken(`${this.portal}/oauth2/token`, {\n      client_id: this.clientId,\n      refresh_token: this.refreshToken,\n      grant_type: \"refresh_token\"\n    }).then(response => {\n      this._token = response.token;\n      this._tokenExpires = response.expires;\n      return this;\n    });\n  }\n\n  /**\n   * Exchanges an expired `refreshToken` for a new one also updates `token` and\n   * `tokenExpires`.\n   */\n  private refreshRefreshToken() {\n    return fetchToken(`${this.portal}/oauth2/token`, {\n      client_id: this.clientId,\n      refresh_token: this.refreshToken,\n      redirect_uri: this.redirectUri,\n      grant_type: \"exchange_refresh_token\"\n    }).then(response => {\n      this._token = response.token;\n      this._tokenExpires = response.expires;\n      this._refreshToken = response.refreshToken;\n      this._refreshTokenExpires = new Date(\n        Date.now() + (this.refreshTokenDuration - 1) * 60 * 1000\n      );\n      return this;\n    });\n  }\n}\n","import { request, IAuthenticationManager } from \"@esri/rest-request\";\nimport { fetchToken } from \"./fetchToken\";\n\nexport interface IApplicationSessionOptions {\n  /**\n   * Client ID of your application. Can be obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise.\n   */\n  clientId: string;\n\n  /**\n   * A Client Secret is also obtained by registering an application\n   * on [ArcGIS for Developers](https://developers.arcgis.com/documentation/core-concepts/security-and-authentication/signing-in-arcgis-online-users/#registering-your-application),\n   * [ArcGIS Online](http://doc.arcgis.com/en/arcgis-online/share-maps/add-items.htm#ESRI_SECTION1_0D1B620254F745AE84F394289F8AF44B) or on your instance of ArcGIS Enterprise. Treat it like a password.\n   */\n  clientSecret: string;\n\n  /**\n   * OAuth 2.0 access token from a previous application session.\n   */\n  token?: string;\n\n  /**\n   * Expiration date for the `token`\n   */\n  expires?: Date;\n\n  /**\n   * Duration of requested tokens in minutes. Used when requesting tokens with `username` and `password` for when validating the identities of unknown servers. Defaults to 2 weeks.\n   */\n  duration?: number;\n}\n\nexport class ApplicationSession implements IAuthenticationManager {\n  private clientId: string;\n  private clientSecret: string;\n  private token: string;\n  private expires: Date;\n  private portal: string;\n  private duration: number;\n\n  constructor(options: IApplicationSessionOptions) {\n    this.clientId = options.clientId;\n    this.clientSecret = options.clientSecret;\n    this.token = options.token;\n    this.expires = options.expires;\n    this.portal = \"https://www.arcgis.com/sharing/rest\";\n    this.duration = options.duration || 20160;\n  }\n\n  getToken(url: string): Promise<string> {\n    if (this.token && this.expires && this.expires.getTime() > Date.now()) {\n      return Promise.resolve(this.token);\n    }\n\n    return this.refreshToken();\n  }\n\n  refreshToken(): Promise<string> {\n    return fetchToken(`${this.portal}/oauth2/token/`, {\n      client_id: this.clientId,\n      client_secret: this.clientSecret,\n      grant_type: \"client_credentials\"\n    }).then(response => {\n      this.token = response.token;\n      this.expires = response.expires;\n      return response.token;\n    });\n  }\n\n  refreshSession() {\n    return this.refreshToken().then(() => this);\n  }\n}\n"],"names":["url","params","request","then","response","r","token","access_token","username","expires","Date","now","expires_in","refresh_token","refreshToken","window","location","host","referer","deferred","promise","resolve","reject","Promise","options","this","clientId","clientSecret","portal","duration","ApplicationSession","getTime","fetchToken","client_id","client_secret","grant_type","_this","_refreshToken","_refreshTokenExpires","refreshTokenExpires","password","_token","_tokenExpires","tokenExpires","tokenDuration","redirectUri","refreshTokenDuration","trustedServers","Object","UserSession","win","_a","popup","encodeURIComponent","session","defer","error","oauthInfo","open","href","opener","parent","close","match","errorMatch","errorMessage","decodeURIComponent","completeSignIn","ArcGISRequestError","parseInt","writeHead","Location","end","authorizationCode","redirect_uri","code","str","JSON","parse","test","getFreshToken","RegExp","getTokenForServer","stringify","refreshWithUsernameAndPassword","refreshWithRefreshToken","Error","root","existingToken","owningSystemUrl","ArcGISAuthError","authInfo","tokenServicesUrl","generateToken","serverUrl","expiration","refreshSession","refreshRefreshToken"],"mappings":"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"}